I see what you’re trying to do here — you want to show **two ways** of implementing a functional interface method:

1. **Traditional way** (via `implements`)
2. **Java 8 Lambda way**

But your code won’t compile as it stands because:

* You’re calling `abstractMethod();` in `main()` without passing parameters, but if your functional interface has a method like

  ```java
  void abstractMethod(String input);
  ```

  you must call it with a string.
* The `LamdaExpression` interface definition is missing from your snippet, so we need to create it.
* The lambda implementations (`method` and `method1`) are defined, but not executed (`method.abstractMethod(...)` is missing).

---

Here’s a **fixed, working version**:

```java
@FunctionalInterface
interface LamdaExpression {
    void abstractMethod(String input);
}

public class LamdaExpresionImpl implements LamdaExpression {

    // Traditional way
    @Override
    public void abstractMethod(String input) {
        System.out.println("Traditional way: " + input);
    }

    public static void main(String[] args) {
        // 1️⃣ Traditional approach using class implementation
        LamdaExpresionImpl obj = new LamdaExpresionImpl();
        obj.abstractMethod("Hello from traditional implementation");

        // 2️⃣ Lambda expression implementation
        LamdaExpression method = (input) -> {
            System.out.println("Lambda way: " + input);
        };
        method.abstractMethod("Hello from lambda");

        // 3️⃣ Method reference implementation
        LamdaExpression method1 = System.out::println;
        method1.abstractMethod("Hello from method reference");
    }
}
```

---

### **How This Works**

1. **Functional Interface**

   * `@FunctionalInterface` ensures only one abstract method exists.
2. **Traditional Implementation**

   * The class `LamdaExpresionImpl` overrides `abstractMethod`.
3. **Lambda Implementation**

   * `(input) -> { ... }` is a shorter way to implement the method inline.
4. **Method Reference**

   * `System.out::println` automatically matches `void abstractMethod(String)`.

---

### **Output**

```
Traditional way: Hello from traditional implementation
Lambda way: Hello from lambda
Hello from method reference
```

---
================================================================================
A lambda expression in Java can only implement the single abstract method (SAM) of a functional interface.
It cannot directly implement or override a default or static method of an interface.

1️⃣ Why you can’t pass default/static methods “through” a lambda
Default methods already have a body — so they are not abstract and don’t need implementing.

Static methods belong to the interface itself, not an instance, so they’re called directly on the interface, not through a lambda.

A lambda only exists to provide the missing implementation for an abstract method in a functional interface.
================================================================================

################################################################
Static methods are utility-like -> their behavior should not depend on the instance or class hierarchy.
################################################################
 Interview Notes
Abstract = “must be implemented.”

Default = “already implemented, but can be overridden.”

Static = “already implemented, belongs to interface, not inheritable.”

Static in Interface ≠ Static in Class —
In a class, a static method is inherited, but in an interface it’s not.------------->important point to be noted
#################################################################
| **Type of Method** | **Has Body?** | **Can Be Overridden?**                               | **Inherited by Implementing Class?** | **Access**            | **Call Syntax**          | **Java Version Introduced** |
| ------------------ | ------------- | ---------------------------------------------------- | ------------------------------------ | --------------------- | ------------------------ | --------------------------- |
| **Abstract**       | ❌ No          | ✅ Yes (must be implemented unless class is abstract) | ✅ Yes                                | `public` (implicitly) | `obj.method()`           | Since Java 1.0              |
| **Default**        | ✅ Yes         | ✅ Yes (optional)                                     | ✅ Yes                                | `public` (implicitly) | `obj.method()`           | Java 8                      |
| **Static**         | ✅ Yes         | ❌ No                                                 | ❌ No                                 | `public` (implicitly) | `InterfaceName.method()` | Java 8                      |
